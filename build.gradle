buildscript {
    repositories {
        mavenLocal()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath "gradle.plugin.org.eclipse.virgo.bundlor:bundlor-plugin:0.2"
    }
}

def timestamp = new Date().format('yyyyMMddHHmmss', TimeZone.getTimeZone('GMT'))

defaultTasks 'clean', 'build', 'javadoc', 'sourcesJar', 'javadocJar', 'collectArtifacts', 'buildCommandlineDist'

ext.javaProjects = [
    project(':org.eclipse.virgo.bundlor'),
    project(':org.eclipse.virgo.bundlor.ant'),
    project(':org.eclipse.virgo.bundlor.blint'),
    project(':org.eclipse.virgo.bundlor.commandline'),
    project(':org.eclipse.virgo.bundlor.maven')    
]

allprojects {
    apply plugin: 'base'
    if (System.properties['ci.build'] == 'true') {
        def buildQualifier = System.properties['ci.build.qualifier']
        if(buildQualifier) { 
            version = version + '.' + buildQualifier
        } else {
            version = version + '.' + timestamp
        }
    } else {
        version = version + '.SNAPSHOT'
    }
}

configure(javaProjects) {
    apply plugin: 'java'
    apply plugin: 'jacoco'
    apply plugin: 'findbugs'

    sourceCompatibility = '1.8'
    targetCompatibility = '1.8'

    compileJava {
        options.encoding = 'UTF-8'
        options.fork = true
        doFirst {
            options.forkOptions.with {
                executable = 'java'
                jvmArgs = [
                    '-cp',
                    configurations.ecj.asPath,
                    'org.eclipse.jdt.internal.compiler.batch.Main',
                    '-warn:-unused']
            }
        }
    }
    compileTestJava {
        options.encoding = 'UTF-8'
        options.fork = true
        doFirst {
            options.forkOptions.with {
                executable = 'java'
                jvmArgs = [
                    '-cp',
                    configurations.ecj.asPath,
                    'org.eclipse.jdt.internal.compiler.batch.Main',
                    '-warn:-unused']
            }
        }
    }
    configurations {
    	ecj {}
		embedded
		compile.extendsFrom(embedded)
		testBundles {
			transitive = false
		}
	}
    repositories {
        mavenCentral()
    }
    test {
    	// we need to set the system properties for the jvm executing the tests explicitly
    	// so we copy system properties relevant for proxying external requests
    	// see Bug 501842 
    	System.properties.each { k,v ->
    		if(k.startsWith('http.') || k.startsWith('https.') || k.startsWith('ftp')) {    		
    			systemProperty k,v
    		}
    	}
    }
    classes.doLast {
    	// including 'embedded' dependencies in archive
    	// doing this here so that bundlor sees the embedded stuff and is able to generate sound manifest file 
    	copy {
    		from project.configurations.embedded.collect { 
    			println '|--> Embedding: ' + it.name
    			it.isDirectory() ? it : zipTree(it)
	    	}
    		into(project.sourceSets.main.output.classesDir)
    	}
    }
    jar {
    	// add SUA to archive
        from "$rootDir/build-bundlor/resources/about/notice.html"
		duplicatesStrategy 'exclude'
    }
    jar.doLast {
    	// signing the archives
        if(System.properties['ci.build.signjars'] == 'true') {
            println '|--> Signing Jar File: ' + archivePath
            exec {
                workingDir destinationDir
                commandLine 'curl',
                            '-o',
                            archiveName,
                            '-F',
                            "file=@${archiveName}",
                            '--show-error',
                            'http://build.eclipse.org:31338/sign'
            }
        }
    }
    jacoco {
        toolVersion = "0.7.4.201502262128"
    }
    findbugs {
        sourceSets = [sourceSets.main]
        ignoreFailures = true
        effort = "max"
        reportLevel = "high"
    }
    javadoc {
        failOnError = false
    }
    test.dependsOn('copyTestBundles')
	task copyTestBundles(){
		doLast {
	     	configurations.testBundles.resolvedConfiguration.resolvedArtifacts.each { artifact ->
	     		copy {
	     			into "$buildDir/testBundles"
	     			from artifact.file
	     			rename '.*', artifact.name + '.jar'
	     		}
	     	}
	    }
	}
    task sourcesJar(type: Jar, dependsOn: classes) {
    	description 'Assembles a jar archive containing the sources.'
    	group = 'build'
	    classifier = 'sources'
    	from sourceSets.main.allSource
	}
	task javadocJar(type: Jar, dependsOn: javadoc) {
	    description 'Assembles a jar archive containing the javadocs.'
    	group = 'build'
	    classifier = 'javadoc'
	    from javadoc.destinationDir
	}
}

configure(javaProjects) {
    apply plugin: 'org.eclipse.virgo.bundlor'
	
	task('addProjectVersionToGradlePropertiesTask', type: Copy) {
		ext.outputDir = new File(buildDir, 'bundlor-properties')
		inputs.file project.rootProject.file('gradle.properties')
		outputs.dir ext.outputDir
		from project.rootProject.file('gradle.properties')
		into ext.outputDir
		doLast {
			def gradleProperties = new Properties()
			gradleProperties.load(new FileReader("${buildDir}/bundlor-properties/gradle.properties"))
			gradleProperties.setProperty('bundleName', "${archivesBaseName}")
			gradleProperties.setProperty('timestamp', "${timestamp}")
			gradleProperties.setProperty('version', "${version}")
			def writer = new FileWriter("${buildDir}/bundlor-properties/gradle.properties")
   			try {
      			gradleProperties.store(writer, 'modified during build process')
      			writer.flush()
   			} finally {
      			writer.close()
   			}
		}
	}
	task('mergeClassesAndResources', type: Copy, dependsOn: 'compileJava') {
		ext.bundlorInputPath = new File(buildDir, 'bundlor-inputPath')
		inputs.file sourceSets.main.output.classesDir
		inputs.file sourceSets.main.resources
		outputs.dir ext.bundlorInputPath
		from sourceSets.main.output.classesDir
		from sourceSets.main.resources
		into ext.bundlorInputPath
	}
	project.tasks.'bundlor'.dependsOn('addProjectVersionToGradlePropertiesTask', 'mergeClassesAndResources')
    bundlor {
    	ext.bundlorInputPath = new File(buildDir, 'bundlor-inputPath')
		project.tasks['bundlor'].inputs.file ext.bundlorInputPath
        manifestTemplatePath = "template.mf"
        propertiesPath = new File("${project.buildDir}/bundlor-properties/gradle.properties")
		inputPath = ext.bundlorInputPath
        failOnWarnings = true
    }
}

//configure(javaProjects) {
//	apply plugin: 'signing'
//	signing {
//		sign configurations.archives
//	}
//}

configure(javaProjects) {
    apply plugin: 'eclipse'

    eclipse {
        jdt {
            sourceCompatibility = 1.8
            targetCompatibility = 1.8
            file.withProperties { p ->
            	p.setProperty('org.eclipse.jdt.core.compiler.problem.discouragedReference','warning')
            	p.setProperty('org.eclipse.jdt.core.compiler.problem.forbiddenReference', 'warning')
            }
        }
        project {
            file.beforeMerged {
                project.natures.clear()
            }
            natures = ['org.eclipse.buildship.core.gradleprojectnature']
        }
    }
    cleanEclipse.doLast {
        delete '.settings'
        delete 'bin'
        delete '.springBeans'
    }
}

configure(javaProjects) {
    apply plugin: 'maven-publish'

    publishing {
        publications {
        	all {
        		pom.withXml {
                    asNode().with {
                        appendNode('description', 'Bundlor is a tool that automates the detection of dependencies and the creation of OSGi manifest directives for JARs after their creation. Bundlor takes as input a JAR and a template consisting of a superset of the standard OSGi manifest headers.')
                        appendNode('url', 'http://www.eclipse.org/virgo/')
                        appendNode('licenses').appendNode('license').with {
                            appendNode('name', 'Eclipse Public License Version 1.0')
                            appendNode('url', 'http://www.eclipse.org/legal/epl-v10.html')
                        }
                        appendNode('developers').appendNode('developer').with {
                            appendNode('id', 'virgo-dev')
                            appendNode('name', 'Virgo Developer List')
                            appendNode('email', 'virgo-dev@eclipse.org')
                            appendNode('url', 'http://projects.eclipse.org/projects/rt.virgo/who/')
                            appendNode('roles').appendNode('role', 'Developer')
                        }
                        appendNode('scm').with {
                            appendNode('connection', 'http://wiki.eclipse.org/Virgo/Source#Virgo_git_Repositories')
                            appendNode('url', 'http://wiki.eclipse.org/Virgo/Source#Virgo_git_Repositories')
                        }
                    }
                    asNode().dependencies.'*'.findAll() {
                    	if('org.eclipse.virgo.util'.equalsIgnoreCase(it.groupId.text())) {
                    		println '|--> Excluding groupId:' + it.groupId.text() + ', artifactId:' + it.artifactId.text() + ' from Maven pom'
                    		it.parent().remove(it)
                    	} 
                    }
                }
        	}
            maven(MavenPublication) {
                from components.java
                artifact sourcesJar
                artifact javadocJar
                groupId 'org.eclipse.virgo.bundlor'
            }
        }
    }
}

task bundlorJarDist(type: Zip) {
	description 'Builds Zip file containg all project Jars'
	group = 'distribution'
	
	archiveName "bundlor-jars-${version}.zip"		
	from javaProjects.jar
	from javaProjects.sourcesJar
	from javaProjects.javadocJar
}

task bundlorCommandlineDist(type: Zip) {
    description 'Build Bundlor Commandline distribution Zip file'
    group = 'distribution'
    
	archiveName "bundlor-commandline-${version}.zip"
    duplicatesStrategy 'exclude'
    into("bundlor-${version}/plugins") {
        from project(':org.eclipse.virgo.bundlor.commandline').jar
        from project(':org.eclipse.virgo.bundlor.commandline').configurations.runtime
    }
    into("bundlor-${version}/bin") {
        from "$rootDir/build-bundlor/resources/bin"
    }
    into("bundlor-${version}") {
        from "$rootDir/build-bundlor/resources/about"
    }
}

task wrapper(type: Wrapper) {
    description 'Creates a local Gradle Wrapper'
    group = 'Build Setup'
    gradleVersion = '3.1'
}
